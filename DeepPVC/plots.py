import os.path

import torch
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
import numpy as np
import time

def show_tensor_images(images, i):
    '''
    Plots PVE, PVfree and GeneratedProjection by patch

    :param images: tensor of images of size (batch_size, 3,128,128)

    Each batch contains 3 images :  [0] Pojection with PVE from dataset
                                    [1] Projection WITHOUT PVE (PVfree) from dataset
                                    [2] Projection Generated by Pix2Pix
    :return: None
    '''

    images_unflat = images.detach().cpu()
    batch_size = images_unflat.shape[0]

    fig,ax = plt.subplots(3,batch_size, squeeze=False)

    for k in range(batch_size):
        maxc = torch.max(images_unflat[k,0:2,:,:])
        minc = torch.min(images_unflat[k,0:2,:,:])
        ax[0,k].imshow(images_unflat[k,0,:,:], vmin = minc, vmax= maxc)
        ax[0,k].set_title('PVE')
        ax[1,k].imshow(images_unflat[k,1,:,:], vmin = minc, vmax= maxc)
        ax[1, k].set_title('PVfree')
        ax[2,k].imshow(images_unflat[k,2,:,:])
        ax[2, k].set_title('FakePVfree')
    plt.show()

    fig,ax = plt.subplots()
    ax.plot(images_unflat[0,0,i,:], label = 'PVE')
    ax.plot(images_unflat[0,1,i,:], label = 'PVfree')
    ax.plot(images_unflat[0,2,i,:], label = 'PVC')
    plt.legend()
    plt.show()


def show_two_images(img_PVE, img_PVC,slice):
    array_PVE = img_PVE.numpy()
    array_PVC = img_PVC.numpy()

    # , cmap = 'Greys'

    fig,ax = plt.subplots(1,2)
    im1 = ax[0].imshow(array_PVE[0,0,:,:])
    ax[0].set_title('Input PVE projection')
    im2 = ax[1].imshow(array_PVC[0,0,:,:])
    ax[1].set_title('Output PVC projection')

    fig.subplots_adjust(right=0.85)
    cbar_ax = fig.add_axes([0.88, 0.15, 0.04, 0.7])
    fig.colorbar(im2, cax=cbar_ax)
    plt.show()

    fig,ax = plt.subplots()
    ax.plot(array_PVE[0,0,slice,:], label = 'PVE')
    ax.plot(array_PVC[0,0,slice,:], label = 'PVC')
    plt.legend()
    plt.show()



def plot_losses(discriminator_losses,generator_losses, test_mse, save = False, wait = False, title = None):
    fig,ax1 = plt.subplots(figsize=(8,6))
    fig.subplots_adjust(right=0.75)

    p1 = ax1.plot(generator_losses, color = 'orange', label = 'Generator Loss')
    ax1.set_ylabel("Generator Loss", color = p1[0].get_color(), fontsize = 14)
    ax1.legend(loc=2) #upper left legend

    ax2 = ax1.twinx()
    p2 = ax2.plot(discriminator_losses,color = 'blue', label= 'Discriminator Loss')
    ax2.set_ylabel("Discriminator Loss", color = p2[0].get_color(),fontsize=14)
    ax2.legend(loc=1) #upper right legend

    if len(test_mse)>0:
        ax3 = ax1.twinx()
        ax3.spines.right.set_position(("axes", 1.2))

        test_epochs = [k[0] for k in test_mse]
        test_mse = [k[1] for k in test_mse]
        p3 = ax3.plot(test_epochs, test_mse, color = 'green', label = 'MSE on test dataset')
        ax3.set_ylabel("MSE test", color = p3[0].get_color(), fontsize = 14)
        ax3.legend(loc = 'upper center')

    ax2.set_xlabel('Iterations')
    if title:
        ax2.set_title('Losses '+title)
    else:
        ax2.set_title('Losses')

    if save:
        figname = time.strftime("%Y%m%d-%H%M%S")+'.png'
        plt.savefig(figname)
    elif wait:
        print('')
    else:
        plt.show()


def show_images_profiles(images,profile = None, save=False,folder = None, is_tensor=True, title = None, labels = None):
    if is_tensor:
        array_image = images.cpu().numpy()
    else:
        array_image = images
    shape = array_image.shape
    nb_image,nb_channels = shape[0], shape[1]

    if (labels and len(labels)!= nb_image):
        print('ERROR: Ya un probleme entre le nombre d images et le nombre de labels donn√©')
        exit(0)
    elif nb_image<2:
        print('ERROR: CA SERT A RIEN DE DONNER MOINS DE DEUX IMAGES HEIN')
    elif not labels:
        if nb_image==2:
            labels = ['PVE', 'Pix2Pix']
        elif nb_image==3:
            labels = ['PVE', 'PVfree', 'Pix2Pix']
        elif nb_image>3:
            labels = ['PVE', 'PVfree']


    if nb_image==2:
        colors = ['red', 'blue']
    elif nb_image==3:
        colors = ['red', 'green', 'blue']
    elif nb_image>3:
        colors = ['red', 'green']
        for k in range(nb_image - 2):
            labels.append(f'Pix2Pix{k}')
            colors.append(tuple(np.random.random(size=3)))  # random color

    nrows = nb_channels
    if profile:
        nrows+=2


    fig = plt.figure(figsize=(12,8))
    gs = GridSpec(nrows,nb_image, figure=fig)


    _vmin = np.min(array_image)
    _vmax = np.max(array_image)
    for c in range(nb_channels):
        for i in range(nb_image):
            ax_imgs_i = fig.add_subplot(gs[c,i])
            ax_imgs_i.imshow(array_image[i,c,:,:], vmin=_vmin, vmax = _vmax)
            ax_imgs_i.set_title(labels[i])


    # compute and plot profiles
    if profile:
        channel = 0
        ref_img = array_image[0,channel,:,:]
        center_indexes = np.where(ref_img == np.amax(ref_img))
        center_i = (np.mean(center_indexes[0])).astype(int)
        center_j = (np.mean(center_indexes[1])).astype(int)

        ax_pfl_i = fig.add_subplot(gs[nb_channels, :])
        ax_pfl_j = fig.add_subplot(gs[nb_channels+1, :])
        for i in range(nb_image):
            ax_pfl_i.plot(array_image[i,channel,center_i,:], color = colors[i], label = labels[i])
            ax_pfl_j.plot(array_image[i,channel,:,center_j], color = colors[i], label = labels[i])
        ax_pfl_i.legend()
        ax_pfl_j.legend()

    if title!=None:
        plt.suptitle(title)

    if save:
        if title:
            figname = title.replace(" ", "")+'.png'
        else:
            figname = time.strftime("%Y%m%d-%H%M%S")+'.png'
        if not folder:
            folder = '.'

        figpath = os.path.join(folder,figname)
        plt.savefig(figpath)
    else:
        plt.show()


