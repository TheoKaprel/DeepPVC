import os.path

import torch
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
import numpy as np
import time

def show_tensor_images(images, i):
    '''
    Plots PVE, PVfree and GeneratedProjection by patch

    :param images: tensor of images of size (batch_size, 3,128,128)

    Each batch contains 3 images :  [0] Pojection with PVE from dataset
                                    [1] Projection WITHOUT PVE (PVfree) from dataset
                                    [2] Projection Generated by Pix2Pix
    :return: None
    '''

    images_unflat = images.detach().cpu()
    batch_size = images_unflat.shape[0]

    fig,ax = plt.subplots(3,batch_size, squeeze=False)

    for k in range(batch_size):
        maxc = torch.max(images_unflat[k,0:2,:,:])
        minc = torch.min(images_unflat[k,0:2,:,:])
        ax[0,k].imshow(images_unflat[k,0,:,:], vmin = minc, vmax= maxc)
        ax[0,k].set_title('PVE')
        ax[1,k].imshow(images_unflat[k,1,:,:], vmin = minc, vmax= maxc)
        ax[1, k].set_title('PVfree')
        ax[2,k].imshow(images_unflat[k,2,:,:])
        ax[2, k].set_title('FakePVfree')
    plt.show()

    fig,ax = plt.subplots()
    ax.plot(images_unflat[0,0,i,:], label = 'PVE')
    ax.plot(images_unflat[0,1,i,:], label = 'PVfree')
    ax.plot(images_unflat[0,2,i,:], label = 'PVC')
    plt.legend()
    plt.show()


def show_two_images(img_PVE, img_PVC,slice):
    array_PVE = img_PVE.numpy()
    array_PVC = img_PVC.numpy()

    # , cmap = 'Greys'

    fig,ax = plt.subplots(1,2)
    im1 = ax[0].imshow(array_PVE[0,0,:,:])
    ax[0].set_title('Input PVE projection')
    im2 = ax[1].imshow(array_PVC[0,0,:,:])
    ax[1].set_title('Output PVC projection')

    fig.subplots_adjust(right=0.85)
    cbar_ax = fig.add_axes([0.88, 0.15, 0.04, 0.7])
    fig.colorbar(im2, cax=cbar_ax)
    plt.show()

    fig,ax = plt.subplots()
    ax.plot(array_PVE[0,0,slice,:], label = 'PVE')
    ax.plot(array_PVC[0,0,slice,:], label = 'PVC')
    plt.legend()
    plt.show()



def plot_losses_G_D(discriminator_losses,generator_losses, test_mse, save = False, wait = False, title = None):
    fontsize = 20

    fig,ax1 = plt.subplots(figsize=(8,6))
    fig.subplots_adjust(right=0.75)

    p1 = ax1.plot(generator_losses, color = 'orange',linewidth = 2, label = 'Generator Loss')
    ax1.set_ylabel("Generator Loss", color = p1[0].get_color(), fontsize = fontsize)
    # ax1.set_ylim([1,16])
    ax1.set_xlabel("# of epochs", fontsize=fontsize)
    ax1.legend(loc=2, fontsize = fontsize) #upper left legend

    ax2 = ax1.twinx()
    p2 = ax2.plot(discriminator_losses,color = 'blue',linewidth = 2, label= 'Discriminator Loss')
    ax2.set_ylabel("Discriminator Loss", color = p2[0].get_color(),fontsize=fontsize)
    # ax2.set_ylim([0.62, 0.7])
    ax2.legend(loc=1, fontsize = fontsize) #upper right legend

    if len(test_mse)>0:
        ax3 = ax1.twinx()
        ax3.spines.right.set_position(("axes", 1.2))
        # ax3.set_ylim([0.0033, 0.0042])
        test_epochs = [k[0] for k in test_mse]
        test_mse = [k[1] for k in test_mse]
        p3 = ax3.plot(test_epochs, test_mse, color = 'green',linewidth = 2, label = 'MSE on test dataset')
        ax3.set_ylabel("MSE test", color = p3[0].get_color(), fontsize = fontsize)

        ax3.legend(loc = 'upper center', fontsize = fontsize)


    ax2.set_xlabel('Iterations')
    if title:
        ax2.set_title('Losses '+title)
    else:
        ax2.set_title('Losses', fontsize = fontsize)

    if save:
        figname = time.strftime("%Y%m%d-%H%M%S")+'.png'
        plt.savefig(figname)
    elif wait:
        print('')
    else:
        plt.show()


def plot_losses_UNet(unet_losses, test_mse, save = False, wait = False, title = None):
    fontsize = 20

    fig,ax1 = plt.subplots(figsize=(8,6))
    fig.subplots_adjust(right=0.75)

    p1 = ax1.plot(unet_losses, color = 'orange',linewidth = 2, label = 'UNet Loss')
    ax1.set_ylabel("UNet Loss", color = p1[0].get_color(), fontsize = fontsize)
    # ax1.set_ylim([1,16])
    ax1.set_xlabel("# of epochs", fontsize=fontsize)
    ax1.legend(loc=2, fontsize = fontsize) #upper left legend

    # ax2 = ax1.twinx()
    # p2 = ax2.plot(discriminator_losses,color = 'blue',linewidth = 2, label= 'Discriminator Loss')
    # ax2.set_ylabel("Discriminator Loss", color = p2[0].get_color(),fontsize=fontsize)
    # # ax2.set_ylim([0.62, 0.7])
    # ax2.legend(loc=1, fontsize = fontsize) #upper right legend

    if len(test_mse)>0:
        ax3 = ax1.twinx()
        ax3.spines.right.set_position(("axes", 1.2))
        # ax3.set_ylim([0.0033, 0.0042])
        test_epochs = [k[0] for k in test_mse]
        test_mse = [k[1] for k in test_mse]
        p3 = ax3.plot(test_epochs, test_mse, color = 'green',linewidth = 2, label = 'MSE on test dataset')
        ax3.set_ylabel("MSE test", color = p3[0].get_color(), fontsize = fontsize)

        ax3.legend(loc = 'upper center', fontsize = fontsize)


    ax1.set_xlabel('Iterations')
    if title:
        ax1.set_title('Losses '+title)
    else:
        ax1.set_title('Losses', fontsize = fontsize)

    if save:
        figname = time.strftime("%Y%m%d-%H%M%S")+'.png'
        plt.savefig(figname)
    elif wait:
        print('')
    else:
        plt.show()




def show_images_profiles(images,profile = None, save=False,folder = None, is_tensor=True, title = None, labels = None):
    if is_tensor:
        array_image = images.cpu().numpy()
    else:
        array_image = images
    shape = array_image.shape
    nb_image,nb_channels = shape[0], shape[1]

    if (labels and len(labels)!= nb_image):
        print('ERROR: Ya un probleme entre le nombre d images et le nombre de labels donn√©')
        exit(0)
    elif nb_image<2:
        print('ERROR: CA SERT A RIEN DE DONNER MOINS DE DEUX IMAGES HEIN')
    elif not labels:
        if nb_image==2:
            labels = ['PVE', 'Pix2Pix']
        elif nb_image==3:
            labels = ['PVE', 'noPVE', 'DeepPVC']
        elif nb_image>3:
            labels = ['PVE', 'noPVE']


    if nb_image==2:
        colors = ['red', 'blue']
    elif nb_image==3:
        colors = ['red', 'green', 'blue']
    elif nb_image>3:
        colors = ['red', 'green']
        for k in range(nb_image - 2):
            labels.append(f'Pix2Pix{k}')
            colors.append(tuple(np.random.random(size=3)))  # random color

    nrows = nb_channels
    if profile:
        nrows+=2


    fig = plt.figure(figsize=(8,7))
    gs = GridSpec(nrows,nb_image, figure=fig)
    plt.subplots_adjust(bottom=0.052, top = 0.943)

    # _vmin = np.min(array_image)
    _vmax = np.max(array_image)
    _vmin = -_vmax/8

    channel = 0
    ref_img = array_image[0, channel, :, :]
    center_indexes = np.where(ref_img == np.amax(ref_img))
    center_i = (np.mean(center_indexes[0])).astype(int)
    center_j = (np.mean(center_indexes[1])).astype(int)

    for c in range(nb_channels):
        for i in range(nb_image):
            ax_imgs_i = fig.add_subplot(gs[c,i])
            ax_imgs_i.imshow(array_image[i,c,:,:], vmin=_vmin, vmax = _vmax, cmap=plt.get_cmap('inferno'))
            ax_imgs_i.set_title(labels[i], fontsize = 15)

            ax_imgs_i.axvline(x=center_j, color='white', linewidth=0.4)
            ax_imgs_i.axhline(y=center_i, color='white', linewidth=0.4)


    # compute and plot profiles
    if profile:
        ax_pfl_i = fig.add_subplot(gs[nb_channels, :])
        ax_pfl_j = fig.add_subplot(gs[nb_channels+1, :])
        for i in range(nb_image):
            ax_pfl_i.plot(array_image[i,channel,center_i,:], color = colors[i], label = labels[i], linewidth = 1.5)
            ax_pfl_j.plot(array_image[i,channel,:,center_j], color = colors[i], label = labels[i], linewidth = 1.5)
        ax_pfl_i.legend(fontsize = 15)
        ax_pfl_j.legend(fontsize = 15)

    # if title!=None:
    #     plt.suptitle(title)

    if save:
        if title:
            figname = title.replace(" ", "")+'.png'
        else:
            figname = time.strftime("%Y%m%d-%H%M%S")+'.png'
        if not folder:
            folder = '.'

        figpath = os.path.join(folder,figname)
        plt.savefig(figpath)
    else:
        plt.show()


